# Current Working Directory: C:\Users\admin\Documents\dev\games\Minesweeper

# Content of readme.md

# Minesweeper Official Rules

## General Definitions

- **Standard Levels**: There are three standard levels in Minesweeper:
  - **Beginner**: 8x8 grid with 10 mines.
  - **Intermediate**: 16x16 grid with 40 mines.
  - **Expert**: 30x16 grid with 99 mines.

- **Square States**: During the game, a square can be in one of the following states:
  - **Closed**: At the start of the game, all squares are 'closed'.
  - **Open**: A square showing either a number or a blank cell is 'open'. Each square can only be opened once. Further clicking on an already open square won't affect the board's status.
  - **Marked as Mine**: A square that has been marked as a mine won't be affected by further clicks that would normally open squares.

- **Mouse Actions**: The following actions are allowed to play and solve Minesweeper:
  - **Left Click**: Carried out when the left mouse button is released over a square inside the Minesweeper window. A left click on a closed square opens that square.
  - **Right Click**: Marks or unmarks a square as a mine.
  - **Double Click**: Opens all surrounding squares if the number of surrounding mines matches the number on the square.

## Allowed Mouse Button Functions

- **Button States**:
  - **Depressed**: The state of the button when it is pressed.
  - **Released**: The state of the button when it is released.
  - **Null**: The state of the button when it is not being interacted with.

- **LMB (Left Mouse Button)**:
  - May open a square only if the sequence of states is `Depress & Release` while the state of other buttons is `Null`.

## Interface

- **Clone Interface**:
  - A clone may process all information that is displayed to the player in an explicit way.
  - The interface is divided into:
    - **Field**: Consists of a grid of squares, each with a state (closed, open, marked as mine).
    - **Rest**: Other elements of the interface that are not part of the field.

## Minesweeper Reveal Algorithm

- The Minesweeper reveal algorithm works as follows:
  1. **Flagging Mines**:
     - If the sum of unrevealed neighbors and flagged neighbors equals the value of the cell, flag the unrevealed neighbors.
  2. **Revealing Squares**:
     - If the number of flagged neighbors equals the cell value, reveal the remaining unrevealed neighbors.
  3. **Recursive Reveal**:
     - If a cell has no adjacent mines, recursively reveal all eight adjacent tiles.
     - When revealing a square with zero adjacent mines, automatically reveal all adjacent squares.
  4. **Displaying Numbers**:
     - If a cell has one or more adjacent mines, display the number of mines next to it.



# Content of main.py

import tkinter as tk
from event_manager import EventManager
from grid_manager import GridManager
from game_manager import GameManager
from timer import Timer
from high_score_manager import HighScoreManager
from input_handler import InputHandler
from persistence_manager import PersistenceManager
from settings_manager import SettingsManager
from ui_manager import UIManager

def main():
    # Initialize root window
    root = tk.Tk()
    root.title("Minesweeper")

    # Initialize managers
    event_manager = EventManager(root)
    persistence_manager = PersistenceManager()
    settings_manager = SettingsManager(persistence_manager)

    # Retrieve game settings
    grid_size = settings_manager.get_setting('grid_size')
    num_mines = settings_manager.get_setting('num_mines')
    window_size = settings_manager.get_setting('window_size')

    # Initialize game components
    grid_manager = GridManager(grid_size, num_mines)
    game_manager = GameManager(grid_manager, event_manager)
    timer = Timer(event_manager)
    high_score_manager = HighScoreManager(persistence_manager)
    input_handler = InputHandler(grid_manager, game_manager, event_manager)

    # Initialize and start UI manager
    ui_manager = UIManager(root, grid_manager, game_manager, timer, high_score_manager, input_handler, event_manager, window_size)

    # Start the game
    game_manager.initialize_game()
    timer.start()

    # Start the main loop
    root.mainloop()

if __name__ == "__main__":
    main()



# Content of game_manager.py

class GameManager:
    def __init__(self, grid_manager, event_manager):
        self.grid_manager = grid_manager
        self.event_manager = event_manager
        self.game_state = 'idle'  # Possible states: 'idle', 'playing', 'won', 'lost'
        self.mines_flagged = 0
        self.cells_revealed = 0

    def initialize_game(self):
        """Initializes the game by creating the grid and placing mines."""
        self.grid_manager.create_grid()
        self.game_state = 'playing'
        self.mines_flagged = 0
        self.cells_revealed = 0
        self.event_manager.dispatch('start_new_game', self.grid_manager.get_grid_size())

    def reveal_cell(self, row, col):
        """Reveals a cell and updates the game state accordingly."""
        if self.game_state != 'playing':
            return

        if self.grid_manager.is_flag(row, col):
            return
        elif self.grid_manager.is_mine(row, col):
            self.game_state = 'lost'
            self.event_manager.dispatch('game_lost', self.grid_manager.get_grid())
        else:
            previous_revealed = len(self.grid_manager.revealed)
            self.grid_manager.reveal_cell(row, col)
            newly_revealed = len(self.grid_manager.revealed) - previous_revealed

            self.cells_revealed += newly_revealed
            self.event_manager.dispatch('cell_revealed', row, col, newly_revealed)
            self.check_win_condition()

    def flag_cell(self, row, col):
        """Flags or unflags a cell as containing a mine."""
        if self.game_state != 'playing':
            return

        flag_change = self.grid_manager.flag_cell(row, col)
        self.mines_flagged += flag_change
        self.event_manager.dispatch('cell_flagged', row, col, flag_change)
        self.check_win_condition()

    def check_win_condition(self):
        """Checks if the player has won the game."""
        if self.mines_flagged == self.grid_manager.get_num_mines() and \
           self.cells_revealed == self.grid_manager.get_total_cells() - self.grid_manager.get_num_mines():
            self.game_state = 'won'
            self.event_manager.dispatch('game_won', self.grid_manager.get_grid())

    def is_game_over(self):
        """Returns True if the game is over (either won or lost), False otherwise."""
        return self.game_state in ['won', 'lost']

    def reset_game(self):
        """Resets the game to its initial state."""
        self.initialize_game()
        self.event_manager.dispatch('game_reset')



# Content of event_manager.py

class EventManager:
    def __init__(self, root):
        self.listeners = {}
        self.root = root

    def subscribe(self, event_name, listener):
        """Subscribe a listener to an event."""
        self.listeners.setdefault(event_name, []).append(listener)

    def dispatch(self, event_name, *args, **kwargs):
        """Dispatch an event to all its listeners."""
        for listener in self.listeners.get(event_name, []):
            listener(*args, **kwargs)



# Content of ui_manager.py

import tkinter as tk
from tkinter import messagebox

class UIManager:
    def __init__(self, root, grid_manager, game_manager, timer, high_score_manager, input_handler, event_manager, window_size):
        self.root = root
        self.grid_manager = grid_manager
        self.game_manager = game_manager
        self.timer = timer
        self.high_score_manager = high_score_manager
        self.input_handler = input_handler
        self.event_manager = event_manager
        self.buttons = []

        self.root.geometry(window_size)  # Set an initial fixed size; adjust according to your grid size
        # self.root.resizable(False, False)  # Disable window resizing from the start

        self.create_widgets()

        # Subscribe to events
        self.event_manager.subscribe('grid_updated', self.update_grid)
        self.event_manager.subscribe('game_won', self.handle_win)
        self.event_manager.subscribe('game_lost', self.handle_loss)
        self.event_manager.subscribe('timer_started', self.update_timer)
        self.event_manager.subscribe('timer_reset', self.reset_timer)
        self.event_manager.subscribe('timer_updated', self.update_timer)

    def create_widgets(self):
        """Create and layout the game grid and UI components."""
        self.frame = tk.Frame(self.root)
        self.frame.pack()

        self.timer_label = tk.Label(self.root, text="Time: 0", font=('Helvetica', 16))
        self.timer_label.pack()

        self.restart_button = tk.Button(self.root, text="Restart", command=self.restart_game)
        self.restart_button.pack()

        self.create_grid_buttons()

    def create_grid_buttons(self):
        """Create buttons for the game grid based on the grid size."""
        for r in range(self.grid_manager.rows):
            row_buttons = []
            for c in range(self.grid_manager.cols):
                button = tk.Button(self.frame, width=3, height=1, font=('Helvetica', 16))
                button.grid(row=r, column=c)
                button.bind('<Button-1>', lambda event, row=r, col=c: self.handle_left_click(row, col))
                button.bind('<Button-3>', lambda event, row=r, col=c: self.handle_right_click(row, col))
                row_buttons.append(button)
            self.buttons.append(row_buttons)

    def update_grid(self, updated_grid):
        """Update the UI based on the current state of the grid."""
        for r in range(self.grid_manager.rows):
            for c in range(self.grid_manager.cols):
                cell = updated_grid[r][c]
                button = self.buttons[r][c]
                
                if cell['revealed']:
                    if cell['value'] == 'M':
                        button.config(text="M", state=tk.DISABLED, relief=tk.SUNKEN, bg='red')
                    elif cell['value'] > 0:
                        button.config(text=str(cell['value']), state=tk.DISABLED, relief=tk.SUNKEN)
                    else:
                        button.config(text="", state=tk.DISABLED, relief=tk.SUNKEN)
                elif cell['flagged']:
                    button.config(text="F", bg='yellow')
                else:
                    button.config(text="", state=tk.NORMAL, relief=tk.RAISED, bg='SystemButtonFace')

    def update_timer(self):
        """Update the timer display."""
        elapsed_time = self.timer.get_elapsed_time()
        self.timer_label.config(text=f"Time: {int(elapsed_time)}")

    def reset_timer(self):
        """Reset the timer display."""
        self.timer_label.config(text="Time: 0")

    def restart_game(self):
        """Handle the restart game button click."""
        self.timer.reset()
        self.game_manager.reset_game()
        self.update_grid(self.grid_manager.get_grid())

    def handle_left_click(self, row, col):
        """Handle the left-click event."""
        self.event_manager.dispatch('left_click', row, col)

    def handle_right_click(self, row, col):
        """Handle the right-click event."""
        self.event_manager.dispatch('right_click', row, col)

    def handle_win(self, grid):
        """Handle game won event."""
        self.timer.stop()
        self.animate_win(grid)
        elapsed_time = self.timer.get_elapsed_time()
        player_name = "Player"  # This could be customized
        self.high_score_manager.add_high_score(player_name, score=1, time=elapsed_time)  # Assuming score is always 1 for a win
        self.show_win_message()

    def animate_win(self, grid):
        """Animate a win by flashing the grid."""
        for _ in range(3):  # Flash 3 times
            for r in range(self.grid_manager.rows):
                for c in range(self.grid_manager.cols):
                    button = self.buttons[r][c]
                    button.config(bg='green')
            self.root.update()
            self.root.after(200)
            for r in range(self.grid_manager.rows):
                for c in range(self.grid_manager.cols):
                    button = self.buttons[r][c]
                    button.config(bg='SystemButtonFace')
            self.root.update()
            self.root.after(200)

    def show_win_message(self):
        """Show the win message after the animation."""
        messagebox.showinfo("You Win!", "Congratulations! You've won the game!")

    def handle_loss(self, grid):
        """Handle game lost event."""
        self.timer.stop()
        self.animate_loss(grid)
        self.show_loss_message()
        self.restart_game()

    def animate_loss(self, grid):
        """Animate a loss by flashing and gradually fading out the grid."""

        try:
            # Flash the grid red a few times
            for _ in range(3):
                for (r, c) in self.grid_manager.mines:
                    button = self.buttons[r][c]
                    button.config(bg='red')
                self.root.update()
                self.root.after(100)

                for (r, c) in self.grid_manager.mines:
                    button = self.buttons[r][c]
                    button.config(bg='black')
                self.root.update()
                self.root.after(100)

            # Vibrate the grid (shift buttons slightly)
            for _ in range(10):
                offset = 1 if _ % 2 == 0 else -1
                self.frame.place(x=offset, y=offset)
                self.root.update()
                self.root.after(50)
            self.frame.place(x=0, y=0)  # Reset position

            # Gradually fade the grid to a dark color
            for intensity in range(255, 50, -5):
                color = f'#{intensity:02x}{intensity:02x}{intensity:02x}'
                for r in range(self.grid_manager.rows):
                    for c in range(self.grid_manager.cols):
                        button = self.buttons[r][c]
                        button.config(bg=color)
                self.root.update()
                self.root.after(50)

            # Disable all buttons
            for r in range(self.grid_manager.rows):
                for c in range(self.grid_manager.cols):
                    button = self.buttons[r][c]
                    button.config(state=tk.DISABLED)
            self.root.update()

        finally:
            # Restore window resizing capability after the animation
            self.root.resizable(True, True)  # Re-enable window resizing

    def show_loss_message(self):
        """Show the loss message after the animation."""
        messagebox.showinfo("Game Over", "Sorry, you lost the game.")


Files excluded from printout: ['event_manager.py', 'high_score_manager.py', 'persistence_manager.py']