# Current Working Directory: C:\Users\admin\Documents\dev\games\Minesweeper

# Content of readme.md

# Minesweeper Official Rules

## General Definitions

- **Standard Levels**: There are three standard levels in Minesweeper:
  - **Beginner**: 8x8 grid with 10 mines.
  - **Intermediate**: 16x16 grid with 40 mines.
  - **Expert**: 30x16 grid with 99 mines.

- **Square States**: During the game, a square can be in one of the following states:
  - **Closed**: At the start of the game, all squares are 'closed'.
  - **Open**: A square showing either a number or a blank cell is 'open'. Each square can only be opened once. Further clicking on an already open square won't affect the board's status.
  - **Marked as Mine**: A square that has been marked as a mine won't be affected by further clicks that would normally open squares.

- **Mouse Actions**: The following actions are allowed to play and solve Minesweeper:
  - **Left Click**: Carried out when the left mouse button is released over a square inside the Minesweeper window. A left click on a closed square opens that square.
  - **Right Click**: Marks or unmarks a square as a mine.
  - **Double Click**: Opens all surrounding squares if the number of surrounding mines matches the number on the square.

## Allowed Mouse Button Functions

- **Button States**:
  - **Depressed**: The state of the button when it is pressed.
  - **Released**: The state of the button when it is released.
  - **Null**: The state of the button when it is not being interacted with.

- **LMB (Left Mouse Button)**:
  - May open a square only if the sequence of states is `Depress & Release` while the state of other buttons is `Null`.

## Interface

- **Clone Interface**:
  - A clone may process all information that is displayed to the player in an explicit way.
  - The interface is divided into:
    - **Field**: Consists of a grid of squares, each with a state (closed, open, marked as mine).
    - **Rest**: Other elements of the interface that are not part of the field.

## Minesweeper Reveal Algorithm

- The Minesweeper reveal algorithm works as follows:
  1. **Flagging Mines**:
     - If the sum of unrevealed neighbors and flagged neighbors equals the value of the cell, flag the unrevealed neighbors.
  2. **Revealing Squares**:
     - If the number of flagged neighbors equals the cell value, reveal the remaining unrevealed neighbors.
  3. **Recursive Reveal**:
     - If a cell has no adjacent mines, recursively reveal all eight adjacent tiles.
     - When revealing a square with zero adjacent mines, automatically reveal all adjacent squares.
  4. **Displaying Numbers**:
     - If a cell has one or more adjacent mines, display the number of mines next to it.



# Content of main.py

import tkinter as tk
from event_manager import EventManager
from grid_manager import GridManager
from game_manager import GameManager
from timer import Timer
from high_score_manager import HighScoreManager
from input_handler import InputHandler
from persistence_manager import PersistenceManager
from settings_manager import SettingsManager
from ui_manager import UIManager

def main():
    # Initialize root window
    root = tk.Tk()
    root.title("Minesweeper")

    # Initialize managers
    event_manager = EventManager(root)
    persistence_manager = PersistenceManager()
    settings_manager = SettingsManager(persistence_manager)

    # Retrieve game settings
    grid_size = settings_manager.get_setting('grid_size')
    num_mines = settings_manager.get_setting('num_mines')
    window_size = settings_manager.get_setting('window_size')

    # Initialize game components
    grid_manager = GridManager(grid_size, num_mines)
    game_manager = GameManager(grid_manager, event_manager)
    timer = Timer(event_manager)
    high_score_manager = HighScoreManager(persistence_manager)
    input_handler = InputHandler(grid_manager, game_manager, event_manager)

    # Initialize and start UI manager
    ui_manager = UIManager(root, grid_manager, game_manager, timer, high_score_manager, input_handler, event_manager, window_size)

    # Start the game
    game_manager.initialize_game()
    timer.start()

    # Start the main loop
    root.mainloop()

if __name__ == "__main__":
    main()



# Content of game_manager.py

class GameManager:
    def __init__(self, grid_manager, event_manager):
        self.grid_manager = grid_manager
        self.event_manager = event_manager
        self.game_state = 'idle'  # Possible states: 'idle', 'playing', 'won', 'lost'
        self.mines_flagged = 0
        self.cells_revealed = 0
        self.first_click = True  # Track whether it's the first click

    def initialize_game(self):
        """Initializes the game grid but delays mine placement until the first click."""
        self.grid_manager.create_grid()
        self.game_state = 'playing'
        self.mines_flagged = 0
        self.cells_revealed = 0
        self.first_click = True  # Reset for new game
        self.event_manager.dispatch('start_new_game', self.grid_manager.get_grid_size())

    def reveal_cell(self, row, col):
        """Reveals a cell and updates the game state accordingly."""
        if self.game_state != 'playing':
            return

        if self.first_click:
            self.grid_manager.place_mines_avoiding_first_click(row, col)  # Delay mine placement
            self.first_click = False

        if self.grid_manager.is_flag(row, col):
            return
        elif self.grid_manager.is_mine(row, col):
            self.game_state = 'lost'
            self.event_manager.dispatch('game_lost', self.grid_manager.get_grid())
        else:
            previous_revealed = len(self.grid_manager.revealed)
            self.grid_manager.reveal_cell(row, col)
            newly_revealed = len(self.grid_manager.revealed) - previous_revealed

            self.cells_revealed += newly_revealed
            self.event_manager.dispatch('cell_revealed', row, col, newly_revealed)
            self.check_win_condition()

    def flag_cell(self, row, col):
        """Flags or unflags a cell as containing a mine."""
        if self.game_state != 'playing':
            return

        flag_change = self.grid_manager.flag_cell(row, col)
        self.mines_flagged += flag_change
        self.event_manager.dispatch('cell_flagged', row, col, flag_change)
        self.check_win_condition()

    def check_win_condition(self):
        """Checks if the player has won the game."""
        if self.mines_flagged == self.grid_manager.get_num_mines() and \
           self.cells_revealed == self.grid_manager.get_total_cells() - self.grid_manager.get_num_mines():
            self.game_state = 'won'
            self.event_manager.dispatch('game_won', self.grid_manager.get_grid())

    def is_game_over(self):
        """Returns True if the game is over (either won or lost), False otherwise."""
        return self.game_state in ['won', 'lost']

    def reset_game(self):
        """Resets the game to its initial state."""
        self.initialize_game()
        self.event_manager.dispatch('game_reset')



# Content of event_manager.py

class EventManager:
    def __init__(self, root):
        self.listeners = {}
        self.root = root

    def subscribe(self, event_name, listener):
        """Subscribe a listener to an event."""
        self.listeners.setdefault(event_name, []).append(listener)

    def dispatch(self, event_name, *args, **kwargs):
        """Dispatch an event to all its listeners."""
        for listener in self.listeners.get(event_name, []):
            listener(*args, **kwargs)


Files excluded from printout: ['event_manager.py', 'high_score_manager.py', 'persistence_manager.py', 'ui_manager.py']